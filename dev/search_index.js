var documenterSearchIndex = {"docs":
[{"location":"#T4APartitionedTT","page":"Home","title":"T4APartitionedTT","text":"Documentation for T4APartitionedTT.\n\n","category":"section"},{"location":"#T4APartitionedTT.LazyContraction","page":"Home","title":"T4APartitionedTT.LazyContraction","text":"Lazy evaluation for contraction of two SubDomainTT objects.\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedTT.PartitionedTT","page":"Home","title":"T4APartitionedTT.PartitionedTT","text":"PartitionedTT is a structure that holds multiple TensorTrains (SubDomainTT) that are associated with different non-overlapping projectors.\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedTT.PartitionedTT-Tuple{Vector{Int64}}","page":"Home","title":"T4APartitionedTT.PartitionedTT","text":"(parttt::PartitionedTT)(multiindex::Vector{Int})\n\nEvaluate the PartitionedTT at the given MultiIndex.\n\nThis function finds the corresponding SubDomainTT using a tree-based search, then evaluates it at the given MultiIndex.\n\nArguments\n\nmultiindex::Vector{Int}: The MultiIndex (vector of site index values) to evaluate at\n\nReturns\n\nThe evaluation value of the corresponding SubDomainTT at the given MultiIndex\n\nThrows\n\nArgumentError if no matching SubDomainTT is found for the given MultiIndex\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.Projector","page":"Home","title":"T4APartitionedTT.Projector","text":"A projector represents a projection of a tensor from a set of its indices to integers. Each index is projected to a positive integer.\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedTT.Projector-Union{Tuple{Pair{ITensors.Index{T}, Int64}}, Tuple{T}} where T","page":"Home","title":"T4APartitionedTT.Projector","text":"Constructing a projector from a single pair of index and integer.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.ProjectorTreeNode","page":"Home","title":"T4APartitionedTT.ProjectorTreeNode","text":"ProjectorTreeNode\n\nA tree node for efficient lookup of SubDomainTT by projector.\n\nFields\n\nsite::Union{Index, Nothing}: The site index used for branching at this node (Nothing for leaf nodes)\nchildren::Dict{Union{Int, Nothing}, ProjectorTreeNode}: Map from projection value to child node\nleaf::Union{Nothing, Tuple{Projector, SubDomainTT}}: Leaf node data (projector and SubDomainTT)\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedTT.SubDomainTT","page":"Home","title":"T4APartitionedTT.SubDomainTT","text":"A TensorTrain with a projector.\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedTT.SubDomainTT-Tuple{Vector{Int64}, AbstractVector{<:ITensors.Index}}","page":"Home","title":"T4APartitionedTT.SubDomainTT","text":"(subdtt::SubDomainTT)(multiindex::Vector{Int}, all_sites::AbstractVector{<:Index})\n\nEvaluate the SubDomainTT at the given MultiIndex.\n\nArguments\n\nmultiindex::Vector{Int}: The MultiIndex (vector of site index values) to evaluate at\nall_sites::AbstractVector{<:Index}: All site indices in the order corresponding to multiindex\n\nReturns\n\nThe evaluation value of the SubDomainTT at the given MultiIndex\n\n\n\n\n\n","category":"method"},{"location":"#Base.:&-Tuple{T4APartitionedTT.Projector, T4APartitionedTT.Projector}","page":"Home","title":"Base.:&","text":"a & b represents the intersection of the indices that a and b are projected at.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Vararg{T4APartitionedTT.PartitionedTT}}","page":"Home","title":"Base.:+","text":"Add two PartitionedTT objects.\n\nIf the two projects have the same projectors in the same order, the resulting PartitionedTT will have the same projectors in the same order. By default, we use directsum algorithm to compute the sum and no truncation is performed.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:<-Tuple{T4APartitionedTT.Projector, T4APartitionedTT.Projector}","page":"Home","title":"Base.:<","text":"a < b means that a is projected at a subset of the indices that b is projected at.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:|-Tuple{T4APartitionedTT.Projector, T4APartitionedTT.Projector}","page":"Home","title":"Base.:|","text":"a | b represents the union of the indices that a and b are projected at.\n\nIf a is projected at inds=1 and b is not projected for the same inds, then a | b is not projected for inds.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{T4APartitionedTT.PartitionedTT, Integer}","page":"Home","title":"Base.getindex","text":"Indexing for PartitionedTT. This is deprecated and will be removed in the future.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isdisjoint-Tuple{AbstractVector{T4APartitionedTT.Projector}}","page":"Home","title":"Base.isdisjoint","text":"Return if projectors are not overlapping\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{T4APartitionedTT.PartitionedTT}","page":"Home","title":"Base.keys","text":"Return the keys, i.e., projectors of the PartitionedTT.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{T4APartitionedTT.PartitionedTT}","page":"Home","title":"Base.length","text":"Get the number of the data in the PartitionedTT. This is NOT the number of sites in the PartitionedTT.\n\n\n\n\n\n","category":"method"},{"location":"#Base.values-Tuple{T4APartitionedTT.PartitionedTT}","page":"Home","title":"Base.values","text":"Return the values, i.e., SubDomainTT of the PartitionedTT.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm-Tuple{T4APartitionedTT.PartitionedTT}","page":"Home","title":"LinearAlgebra.norm","text":"Return the norm of the PartitionedTT.\n\n\n\n\n\n","category":"method"},{"location":"#T4AITensorCompat.contract-Tuple{T4APartitionedTT.PartitionedTT, T4APartitionedTT.PartitionedTT}","page":"Home","title":"T4AITensorCompat.contract","text":"Contract two T4APartitionedTTs MPS objects.\n\nAt each site, the objects must share at least one site index.\n\n\n\n\n\n","category":"method"},{"location":"#T4AITensorCompat.contract-Tuple{T4APartitionedTT.SubDomainTT, T4APartitionedTT.SubDomainTT}","page":"Home","title":"T4AITensorCompat.contract","text":"Contraction of two SubDomainTTs.  Only if the shared projected indices overlap the contraction is non-vanishing.\n\n\n\n\n\n","category":"method"},{"location":"#T4AITensorCompat.truncate-Tuple{T4APartitionedTT.PartitionedTT}","page":"Home","title":"T4AITensorCompat.truncate","text":"Truncate a PartitionedTT object piecewise.\n\nEach SubDomainTT in the PartitionedTT is truncated independently, but the cutoff is adjusted according to the norm of each SubDomainTT. The total error is the sum of the errors in each SubDomainTT.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT._add_patching-Tuple{AbstractVector{T4APartitionedTT.SubDomainTT}}","page":"Home","title":"T4APartitionedTT._add_patching","text":"Add multiple SubDomainTT objects on the same projector.\n\nIf the bond dimension of the result reaches maxdim, perform patching recursively to reduce the bond dimension.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT._build_tree_recursive-Tuple{T4APartitionedTT.PartitionedTT, AbstractVector{<:ITensors.Index}, Dict{T4APartitionedTT.Projector, T4APartitionedTT.SubDomainTT}}","page":"Home","title":"T4APartitionedTT._build_tree_recursive","text":"_build_tree_recursive(\n    parttt::PartitionedTT,\n    remaining_sites::Vector{Index},\n    remaining_patches::Dict{Projector, SubDomainTT}\n)::ProjectorTreeNode\n\nRecursively build the projector tree.\n\nArguments\n\nparttt::PartitionedTT: The PartitionedTT (used for reference)\nremaining_sites::Vector{Index}: Sites not yet used for branching\nremaining_patches::Dict{Projector, SubDomainTT}: Patches not yet assigned to leaf nodes\n\nReturns\n\nProjectorTreeNode: A tree node (internal or leaf)\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT._next_projindex-Tuple{T4APartitionedTT.Projector, Any}","page":"Home","title":"T4APartitionedTT._next_projindex","text":"Return the next index to be projected.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT._patch-Tuple{T4APartitionedTT.SubDomainTT, Any}","page":"Home","title":"T4APartitionedTT._patch","text":"Adaptive patching\n\nDo patching recursively to reduce the bond dimension. If the bond dimension of a SubDomainTT exceeds maxdim, perform patching.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.adaptive_patching-Tuple{T4APartitionedTT.PartitionedTT, AbstractVector{<:ITensors.Index}}","page":"Home","title":"T4APartitionedTT.adaptive_patching","text":"Adaptive patching\n\nDo patching recursively to reduce the bond dimension. If the bond dimension of a SubDomainTT exceeds maxdim, perform patching.\n\nTruncation Scheme\n\nEach patch is truncated using abs_cutoff = cutoff * total_norm2, where total_norm2 is the sum of squared norms of all patches in the PartitionedTT. This means each patch uses the same absolute cutoff value based on the total norm of the entire PartitionedTT.\n\nNote: This truncation scheme can lead to the total relative error exceeding cutoff when there are many patches,  since the errors from individual patches accumulate. The total error is approximately bounded by cutoff * number_of_patches  in the worst case, rather than cutoff.\n\nArguments\n\nprjtts::PartitionedTT: The partitioned MPS to perform adaptive patching on\npatchorder::AbstractVector{<:Index}: The order of indices to use for patching\n\nKeyword Arguments\n\ncutoff: Relative cutoff threshold (default: default_cutoff())\nmaxdim: Maximum bond dimension (default: default_maxdim())\n\nReturns\n\nPartitionedTT: A new PartitionedTT with patches that have bond dimensions â‰¤ maxdim\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.adaptivecontract-Union{Tuple{IndsT}, Tuple{T4APartitionedTT.PartitionedTT, T4APartitionedTT.PartitionedTT}, Tuple{T4APartitionedTT.PartitionedTT, T4APartitionedTT.PartitionedTT, AbstractArray{ITensors.Index{IndsT}, 1}}} where IndsT","page":"Home","title":"T4APartitionedTT.adaptivecontract","text":"Perform contraction of two PartitionedTT objects.\n\nThe resulting patches after the contraction are patch-added if projected on the same final patch. \n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.add_patching-Tuple{AbstractVector{T4APartitionedTT.PartitionedTT}}","page":"Home","title":"T4APartitionedTT.add_patching","text":"Add multiple PartitionedTT objects.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.automul-Tuple{T4APartitionedTT.PartitionedTT, T4APartitionedTT.PartitionedTT}","page":"Home","title":"T4APartitionedTT.automul","text":"function automul(\n    M1::PartitionedTT,\n    M2::PartitionedTT;\n    tag_row::String=\"\",\n    tag_shared::String=\"\",\n    tag_col::String=\"\",\n    ...\n\n)\n\nPerforms automatic multiplication between partitioned TensorTrains. Automatic multiplication is defined as:\n\n   (fg) (sigma_row sigma_col xi) = sum_sigma_shared \n   f(sigma_row sigma_shared xi) g(sigma_shared sigma_col  xi)\n\nBy default, only element-wise product on sites xi will be performed. See also: elemmul.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.build_projector_tree-Tuple{T4APartitionedTT.PartitionedTT, AbstractVector{<:ITensors.Index}}","page":"Home","title":"T4APartitionedTT.build_projector_tree","text":"build_projector_tree(parttt::PartitionedTT, all_sites::Vector{Index})::ProjectorTreeNode\n\nBuild a tree structure for efficient lookup of SubDomainTT by projector.\n\nThe tree is built by selecting sites with the highest projection frequency at each level, creating a decision tree that minimizes the average search depth.\n\nArguments\n\nparttt::PartitionedTT: The PartitionedTT to build a tree for\nall_sites::Vector{Index}: All site indices in order\n\nReturns\n\nProjectorTreeNode: Root of the projector tree\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.combinesites-Tuple{T4AITensorCompat.TensorTrain, ITensors.Index, ITensors.Index}","page":"Home","title":"T4APartitionedTT.combinesites","text":"Contract two adjacent tensors in TensorTrain\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.contract!-Tuple{T4APartitionedTT.PartitionedTT, T4APartitionedTT.PartitionedTT, T4APartitionedTT.PartitionedTT}","page":"Home","title":"T4APartitionedTT.contract!","text":"Contract two PartitionedTT objects.\n\nExisting patches M in the resulting PartitionedTT will be overwritten if overwrite=true.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.count_site_projections-Tuple{T4APartitionedTT.PartitionedTT, AbstractVector{<:ITensors.Index}}","page":"Home","title":"T4APartitionedTT.count_site_projections","text":"count_site_projections(parttt::PartitionedTT, all_sites::Vector{Index})::Dict{Index, Int}\n\nCount how many patches project at each site.\n\nArguments\n\nparttt::PartitionedTT: The PartitionedTT to analyze\nall_sites::Vector{Index}: All site indices in order\n\nReturns\n\nDict{Index, Int}: Map from site index to count of patches that project at that site\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.elemmul-Tuple{T4APartitionedTT.PartitionedTT, T4APartitionedTT.PartitionedTT}","page":"Home","title":"T4APartitionedTT.elemmul","text":"function elemmul(\n    M1::PartitionedTT,\n    M2::PartitionedTT\n)\n\nPerforms elementwise multiplication between partitioned TensorTrains. Element-wise product is defined  as: \n\n   (fg) (xi) = f(xi)g(xi) = sum_xi f(xi xi) g(xi)\n\nwhere f(xi xi) = f(xi) delta_xi xi. \n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.extractdiagonal-Tuple{T4APartitionedTT.PartitionedTT, Any}","page":"Home","title":"T4APartitionedTT.extractdiagonal","text":"Extract diagonal of the PartitionedTT for s, s', ... for a given site index s, where s must have a prime level of 0.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.find_in_tree-Tuple{T4APartitionedTT.ProjectorTreeNode, T4APartitionedTT.Projector, AbstractVector{<:ITensors.Index}}","page":"Home","title":"T4APartitionedTT.find_in_tree","text":"find_in_tree(\n    tree::ProjectorTreeNode,\n    target_projector::Projector,\n    all_sites::Vector{Index}\n)::Union{Nothing, SubDomainTT}\n\nFind the matching SubDomainTT in the tree for the given target_projector.\n\nArguments\n\ntree::ProjectorTreeNode: Root of the projector tree\ntarget_projector::Projector: The projector to search for\nall_sites::Vector{Index}: All site indices in order\n\nReturns\n\nUnion{Nothing, SubDomainTT}: The matching SubDomainTT, or nothing if not found\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.findallsites_by_tag-Union{Tuple{Array{ITensors.Index{T}, 1}}, Tuple{T}} where T","page":"Home","title":"T4APartitionedTT.findallsites_by_tag","text":"Find sites with the given tag\n\nFor tag = x, if sites contains an Index object with x, the function returns a vector containing only its positon.\n\nIf not, the function seach for all Index objects with tags x=1, x=2, ..., and return their positions.\n\nIf no Index object is found, an empty vector will be returned.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.makesitediagonal-Union{Tuple{IndsT}, Tuple{T4APartitionedTT.PartitionedTT, AbstractArray{ITensors.Index{IndsT}, 1}}} where IndsT","page":"Home","title":"T4APartitionedTT.makesitediagonal","text":"Make the PartitionedTT diagonal for a given site index s by introducing a dummy index s'.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.noprime-Union{Tuple{T4APartitionedTT.Projector}, Tuple{T}} where T","page":"Home","title":"T4APartitionedTT.noprime","text":"Remove prime level in projected indices.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.prime","page":"Home","title":"T4APartitionedTT.prime","text":"Prime projected indices.\n\n\n\n\n\n","category":"function"},{"location":"#T4APartitionedTT.projcontract-Tuple{AbstractVector{T4APartitionedTT.SubDomainTT}, AbstractVector{T4APartitionedTT.SubDomainTT}, T4APartitionedTT.Projector}","page":"Home","title":"T4APartitionedTT.projcontract","text":"Project SubDomainTT vectors to proj before computing all possible pairwise contractions of the elements. The results are summed or patch-summed if belonging to the same patch.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.projcontract-Tuple{T4APartitionedTT.SubDomainTT, T4APartitionedTT.SubDomainTT, T4APartitionedTT.Projector}","page":"Home","title":"T4APartitionedTT.projcontract","text":"Project two SubDomainTT objects to proj before contracting them.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.project-Tuple{T4APartitionedTT.LazyContraction, T4APartitionedTT.Projector}","page":"Home","title":"T4APartitionedTT.project","text":"Project the LazyContraction object to prj before evaluating it.\n\nThis may result in projecting the external indices of a and b.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.rearrange_siteinds-Tuple{T4APartitionedTT.PartitionedTT, Any}","page":"Home","title":"T4APartitionedTT.rearrange_siteinds","text":"Rearrange the site indices of the PartitionedTT according to the given order. If nessecary, tensors are fused or split to match the new order.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedTT.siteindices-Tuple{T4APartitionedTT.PartitionedTT}","page":"Home","title":"T4APartitionedTT.siteindices","text":"Return the site indices of the PartitionedTT. The site indices are returned as a vector of sets, where each set corresponds to the site indices at each site.\n\n\n\n\n\n","category":"method"}]
}
