var documenterSearchIndex = {"docs":
[{"location":"#T4APartitionedMPSs","page":"Home","title":"T4APartitionedMPSs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for T4APartitionedMPSs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#T4APartitionedMPSs.LazyContraction","page":"Home","title":"T4APartitionedMPSs.LazyContraction","text":"Lazy evaluation for contraction of two SubDomainMPS objects.\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedMPSs.PartitionedMPS","page":"Home","title":"T4APartitionedMPSs.PartitionedMPS","text":"PartitionedMPS is a structure that holds multiple MPSs (SubDomainMPS) that are associated with different non-overlapping projectors.\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedMPSs.Projector","page":"Home","title":"T4APartitionedMPSs.Projector","text":"A projector represents a projection of a tensor from a set of its indices to integers. Each index is projected to a positive integer.\n\n\n\n\n\n","category":"type"},{"location":"#T4APartitionedMPSs.Projector-Union{Tuple{Pair{ITensors.Index{T}, Int64}}, Tuple{T}} where T","page":"Home","title":"T4APartitionedMPSs.Projector","text":"Constructing a projector from a single pair of index and integer.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.SubDomainMPS","page":"Home","title":"T4APartitionedMPSs.SubDomainMPS","text":"An MPS with a projector.\n\n\n\n\n\n","category":"type"},{"location":"#Base.:&-Tuple{T4APartitionedMPSs.Projector, T4APartitionedMPSs.Projector}","page":"Home","title":"Base.:&","text":"a & b represents the intersection of the indices that a and b are projected at.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:+-Tuple{Vararg{T4APartitionedMPSs.PartitionedMPS}}","page":"Home","title":"Base.:+","text":"Add two PartitionedMPS objects.\n\nIf the two projects have the same projectors in the same order, the resulting PartitionedMPS will have the same projectors in the same order. By default, we use directsum algorithm to compute the sum and no truncation is performed.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:<-Tuple{T4APartitionedMPSs.Projector, T4APartitionedMPSs.Projector}","page":"Home","title":"Base.:<","text":"a < b means that a is projected at a subset of the indices that b is projected at.\n\n\n\n\n\n","category":"method"},{"location":"#Base.:|-Tuple{T4APartitionedMPSs.Projector, T4APartitionedMPSs.Projector}","page":"Home","title":"Base.:|","text":"a | b represents the union of the indices that a and b are projected at.\n\nIf a is projected at inds=1 and b is not projected for the same inds, then a | b is not projected for inds.\n\n\n\n\n\n","category":"method"},{"location":"#Base.getindex-Tuple{T4APartitionedMPSs.PartitionedMPS, Integer}","page":"Home","title":"Base.getindex","text":"Indexing for PartitionedMPS. This is deprecated and will be removed in the future.\n\n\n\n\n\n","category":"method"},{"location":"#Base.isdisjoint-Tuple{AbstractVector{T4APartitionedMPSs.Projector}}","page":"Home","title":"Base.isdisjoint","text":"Return if projectors are not overlapping\n\n\n\n\n\n","category":"method"},{"location":"#Base.keys-Tuple{T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"Base.keys","text":"Return the keys, i.e., projectors of the PartitionedMPS.\n\n\n\n\n\n","category":"method"},{"location":"#Base.length-Tuple{T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"Base.length","text":"Get the number of the data in the PartitionedMPS. This is NOT the number of sites in the PartitionedMPS.\n\n\n\n\n\n","category":"method"},{"location":"#Base.values-Tuple{T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"Base.values","text":"Return the values, i.e., SubDomainMPS of the PartitionedMPS.\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.norm-Tuple{T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"LinearAlgebra.norm","text":"Return the norm of the PartitionedMPS.\n\n\n\n\n\n","category":"method"},{"location":"#T4AITensorCompat.contract-Tuple{T4APartitionedMPSs.PartitionedMPS, T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"T4AITensorCompat.contract","text":"Contract two T4APartitionedMPSs MPS objects.\n\nAt each site, the objects must share at least one site index.\n\n\n\n\n\n","category":"method"},{"location":"#T4AITensorCompat.contract-Tuple{T4APartitionedMPSs.SubDomainMPS, T4APartitionedMPSs.SubDomainMPS}","page":"Home","title":"T4AITensorCompat.contract","text":"Contraction of two SubDomainMPSs.  Only if the shared projected indices overlap the contraction is non-vanishing.\n\n\n\n\n\n","category":"method"},{"location":"#T4AITensorCompat.truncate-Tuple{T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"T4AITensorCompat.truncate","text":"Truncate a PartitionedMPS object piecewise.\n\nEach SubDomainMPS in the PartitionedMPS is truncated independently, but the cutoff is adjusted according to the norm of each SubDomainMPS. The total error is the sum of the errors in each SubDomainMPS.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs._add_patching-Tuple{AbstractVector{T4APartitionedMPSs.SubDomainMPS}}","page":"Home","title":"T4APartitionedMPSs._add_patching","text":"Add multiple SubDomainMPS objects on the same projector.\n\nIf the bond dimension of the result reaches maxdim, perform patching recursively to reduce the bond dimension.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs._next_projindex-Tuple{T4APartitionedMPSs.Projector, Any}","page":"Home","title":"T4APartitionedMPSs._next_projindex","text":"Return the next index to be projected.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.adaptive_patching-Tuple{T4APartitionedMPSs.PartitionedMPS, Any}","page":"Home","title":"T4APartitionedMPSs.adaptive_patching","text":"Adaptive patching\n\nDo patching recursively to reduce the bond dimension. If the bond dimension of a SubDomainMPS exceeds maxdim, perform patching.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.adaptive_patching-Tuple{T4APartitionedMPSs.SubDomainMPS, Any}","page":"Home","title":"T4APartitionedMPSs.adaptive_patching","text":"Adaptive patching\n\nDo patching recursively to reduce the bond dimension. If the bond dimension of a SubDomainMPS exceeds maxdim, perform patching.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.adaptivecontract-Union{Tuple{IndsT}, Tuple{T4APartitionedMPSs.PartitionedMPS, T4APartitionedMPSs.PartitionedMPS}, Tuple{T4APartitionedMPSs.PartitionedMPS, T4APartitionedMPSs.PartitionedMPS, AbstractArray{ITensors.Index{IndsT}, 1}}} where IndsT","page":"Home","title":"T4APartitionedMPSs.adaptivecontract","text":"Perform contraction of two PartitionedMPS objects.\n\nThe resulting patches after the contraction are patch-added if projected on the same final patch. \n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.add_patching-Tuple{AbstractVector{T4APartitionedMPSs.PartitionedMPS}}","page":"Home","title":"T4APartitionedMPSs.add_patching","text":"Add multiple PartitionedMPS objects.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.automul-Tuple{T4APartitionedMPSs.PartitionedMPS, T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"T4APartitionedMPSs.automul","text":"function automul(\n    M1::PartitionedMPS,\n    M2::PartitionedMPS;\n    tag_row::String=\"\",\n    tag_shared::String=\"\",\n    tag_col::String=\"\",\n    ...\n\n)\n\nPerforms automatic multiplication between partitioned MPSs. Automatic multiplication is defined as:\n\n   (fg) (sigma_row sigma_col xi) = sum_sigma_shared \n   f(sigma_row sigma_shared xi) g(sigma_shared sigma_col  xi)\n\nBy default, only element-wise product on sites xi will be performed. See also: elemmul.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.combinesites-Tuple{T4AITensorCompat.TensorTrain, ITensors.Index, ITensors.Index}","page":"Home","title":"T4APartitionedMPSs.combinesites","text":"Contract two adjacent tensors in TensorTrain\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.contract!-Tuple{T4APartitionedMPSs.PartitionedMPS, T4APartitionedMPSs.PartitionedMPS, T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"T4APartitionedMPSs.contract!","text":"Contract two PartitionedMPS objects.\n\nExisting patches M in the resulting PartitionedMPS will be overwritten if overwrite=true.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.elemmul-Tuple{T4APartitionedMPSs.PartitionedMPS, T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"T4APartitionedMPSs.elemmul","text":"function elemmul(\n    M1::PartitionedMPS,\n    M2::PartitionedMPS\n)\n\nPerforms elementwise multiplication between partitioned MPSs. Element-wise product is defined  as: \n\n   (fg) (xi) = f(xi)g(xi) = sum_xi f(xi xi) g(xi)\n\nwhere f(xi xi) = f(xi) delta_xi xi. \n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.extractdiagonal-Tuple{T4APartitionedMPSs.PartitionedMPS, Any}","page":"Home","title":"T4APartitionedMPSs.extractdiagonal","text":"Extract diagonal of the PartitionedMPS for s, s', ... for a given site index s, where s must have a prime level of 0.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.findallsites_by_tag-Union{Tuple{Array{ITensors.Index{T}, 1}}, Tuple{T}} where T","page":"Home","title":"T4APartitionedMPSs.findallsites_by_tag","text":"Find sites with the given tag\n\nFor tag = x, if sites contains an Index object with x, the function returns a vector containing only its positon.\n\nIf not, the function seach for all Index objects with tags x=1, x=2, ..., and return their positions.\n\nIf no Index object is found, an empty vector will be returned.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.makesitediagonal-Union{Tuple{IndsT}, Tuple{T4APartitionedMPSs.PartitionedMPS, AbstractArray{ITensors.Index{IndsT}, 1}}} where IndsT","page":"Home","title":"T4APartitionedMPSs.makesitediagonal","text":"Make the PartitionedMPS diagonal for a given site index s by introducing a dummy index s'.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.noprime-Union{Tuple{T4APartitionedMPSs.Projector}, Tuple{T}} where T","page":"Home","title":"T4APartitionedMPSs.noprime","text":"Remove prime level in projected indices.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.prime","page":"Home","title":"T4APartitionedMPSs.prime","text":"Prime projected indices.\n\n\n\n\n\n","category":"function"},{"location":"#T4APartitionedMPSs.projcontract-Tuple{AbstractVector{T4APartitionedMPSs.SubDomainMPS}, AbstractVector{T4APartitionedMPSs.SubDomainMPS}, T4APartitionedMPSs.Projector}","page":"Home","title":"T4APartitionedMPSs.projcontract","text":"Project SubDomainMPS vectors to proj before computing all possible pairwise contractions of the elements. The results are summed or patch-summed if belonging to the same patch.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.projcontract-Tuple{T4APartitionedMPSs.SubDomainMPS, T4APartitionedMPSs.SubDomainMPS, T4APartitionedMPSs.Projector}","page":"Home","title":"T4APartitionedMPSs.projcontract","text":"Project two SubDomainMPS objects to proj before contracting them.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.project-Tuple{T4APartitionedMPSs.LazyContraction, T4APartitionedMPSs.Projector}","page":"Home","title":"T4APartitionedMPSs.project","text":"Project the LazyContraction object to prj before evaluating it.\n\nThis may result in projecting the external indices of a and b.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.rearrange_siteinds-Tuple{T4APartitionedMPSs.PartitionedMPS, Any}","page":"Home","title":"T4APartitionedMPSs.rearrange_siteinds","text":"Rearrange the site indices of the PartitionedMPS according to the given order. If nessecary, tensors are fused or split to match the new order.\n\n\n\n\n\n","category":"method"},{"location":"#T4APartitionedMPSs.siteindices-Tuple{T4APartitionedMPSs.PartitionedMPS}","page":"Home","title":"T4APartitionedMPSs.siteindices","text":"Return the site indices of the PartitionedMPS. The site indices are returned as a vector of sets, where each set corresponds to the site indices at each site.\n\n\n\n\n\n","category":"method"}]
}
